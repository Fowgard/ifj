1. Definice promÄ›nÃ½ch: 
	-Definuje se tak, Å¾e se napÃ­Å¡e nazev promÄ›nÃ© a "=", tento okamÅ¾ik je promÄ›nÃ¡ rovna nil
	- pÅ™i definici promÄ›nÃ© nesmÃ­ chybÄ›t prava strana ( nÄ›co za "=" - mÅ¯Å¾e to byt ale promÄ›nÃ¡ kterou definujeme)
	-Nelze definovat promÄ›nnou stejnÃ©ho jmÃ©na, jako mÃ¡ nÄ›kterÃ¡ jiÅ¾ definovanÃ¡ funkce, a naopak nelze definovat funkce stejnÃ©ho jmÃ©na jako nÄ›kterÃ¡ jiÅ¾ definovanÃ¡ promÄ›nnÃ¡ v hlavnÃ­m tÄ›le programu. @jinak ERROR_3
	-IFJ18 pouÅ¾Ã­vÃ¡ jenom lokÃ¡lnÃ­ promÄ›nÃ© 
	-PromÄ›nnou nelze pouÅ¾Ã­t pÅ™ed jejÃ­ definicÃ­. @jinak ERROR_3

2. Funkce

	2.1 definice funkce:
	#	def id ( parametr1, parametr2, ... paramtrn ) EOL //mÅ¯Å¾e bÃ½t bez parametrÅ¯
	#		sekvence_pÅ™Ã­kazÅ¯
	#	end

		-NemusÃ­ bÃ½t definovanÃ¡ lexikÃ¡lnÄ› pÅ™ed svÃ½m pouÅ¾itÃ­m // To nÃ¡m to trochu zhorÅ¡Ã­ bych Å™ekl .. Ale dalo by se asi udÄ›lat to Å¾e pÅ™i volanÃ­ si zapamatujeme tu funkci a dÃ¡t k nÃ­ nÄ›jakej flag nebo tak nÄ›co, Å¾e jeÅ¡tÄ› nebyla definovÃ¡na 
		-"V tÄ›le funkce jsou jejÃ­ parametry chÃ¡pÃ¡ny jako pÅ™eddefinovanÃ© lokÃ¡lnÃ­ promÄ›nnÃ©."
		-Funkce "vracÃ­" hodnotu naposledy vyhodnocenÃ©ho pÅ™Ã­kazu tÄ›la funkce.

	2.2 VolÃ¡nÃ­ funkce
	# 	id = nÃ¡zev_funkce(parametr1, parametr2, ...) //mÅ¯Å¾e bÃ½t bez parametrÅ¯
		
		-ZÃ¡vorky kolem seznamu vstupnÃ­ch parametrÅ¯ mohou bÃ½t vynechÃ¡ny
		-MusÃ­me kontrolovat poÄet parametrÅ¯ pÅ™i definici a pÅ™i volÃ¡nÃ­. @jinak ERROR_5
		-ÄŒÃ¡st 'id =' lze vynechat pokud tam bude, zapÃ­Å¡e se do nÃ­ hodnota funkce

3. PÅ™Ã­kazy:

	3.1 PÅ™Ã­kaz pÅ™iÅ™azenÃ­:
	#	id = vÃ½raz //id musÃ­ bÃ½t promÄ›nÃ¡ 

		-VyhodnocenÃ­ vÃ½razu -> pÅ™iÅ™azenÃ­ hodnoty do id -> id potom bude stejnÃ©ho typu jako vÃ½raz.
		-ÄŒÃ¡st 'id =' mÅ¯Å¾e bÃ½t vynechÃ¡na, vÃ½raz potom bude slouÅ¾it nejspÃ­Å¡e jako nÃ¡vratovÃ¡ hodnota funkce.

	3.2 PodmÃ­nÄ›nÃ½ pÅ™Ã­kaz:
	#	if vÃ½raz then EOL
	#		sekvence_pÅ™Ã­kazÅ¯1
	#	else EOL
	#		sekvence_pÅ™Ã­kazÅ¯2
	#	end	

		-VyhodnocenÃ­ vÃ½razu -> pokud pravda sekvence_pÅ™Ã­kazÅ¯1, jinak sekvence_pÅ™Ã­kazÅ¯2 ( Jinak pokud to nenÃ­ bool tak se bere hodnota ( nil = false zbytek = true))
		-VÃ½sledkem pÅ™Ã­kazu je vÃ½sledek poslednÃ­ho provedenÃ©ho pÅ™Ã­kazu z provedenÃ© sekvence pÅ™Ã­kazÅ¯. Je-li sekvence prÃ¡zdnÃ¡, je vÃ½sledek nil.

	3.3 PÅ™Ã­kaz pÅ™iÅ™azenÃ­:
	#	while vÃ½raz do EOL
	#		sekvence_pÅ™Ã­kazÅ¯
	#	end

		-ObdobnÄ› jako v C dÄ›lÃ¡ do te doby dokud je vÃ½raz true nebo se nerovnÃ¡ nil.
		-VÃ½sledek tohoto pÅ™Ã­kazu je vÅ¾dy nil.

4. VÃ½razy
	- VÃ½razy jsou tvoÅ™eny termy, zÃ¡vorkami a binÃ¡rnÃ­mi aritmetickÃ½mi, Å™etÄ›zcovÃ½m a relaÄnÃ­mioperÃ¡tory.
	- Jde dÄ›lat implicitnÃ­ konverze datovÃ½ch typÅ¯ z Float na Integer a naopak.
	@chybnÃ© kombinace datovÃ½ch typÅ¯, kterÃ© jsme schopni ovÄ›Å™it u pÅ™ekladu ERROR_4 ( tady je to myÅ¡leno asi tak, Å¾e se mÅ¯Å¾ou vyskytnout chybi i u generovÃ¡nÃ­ nevÃ­m teda jakÃ½ ale pÃ­Å¡e se - "OstatnÃ­ typovÃ© kontroly generujte do mezikÃ³du a pÅ™i bÄ›hovÃ© chybÄ› kvÅ¯li nekompatibilitÄ› typÅ¯ ukonÄete interpret s nÃ¡vratovÃ½m kÃ³dem 4.")

	4.1 AritmetickÃ©, Å™etÄ›zcovÃ© a relaÄnÃ­ operÃ¡tory
		-"+" speciÃ¡lnÄ› pro string provadÃ­ konkatenaci.
		-"+, -, *, /" float = float "+, -, *, /" integer || float =  integer "+, -, *, /" float || integer = integer "+, -, *, /" integer 
		- pozn. u integer = integer "+, -, *, /" integer se jednÃ¡ o celoÄÃ­selnÃ© dÄ›lenÃ­
		@pÅ™i dÄ›lenÃ­ nulou ERROR_9 
		-"<, >, <=, >=, ==, !=" vracÃ­ pravdivostnÃ­ hodnotu, jde porovnat Integer, Float nebo String. Pokud se porovnÃ¡vÃ¡ integer a float tak se integer pÅ™evede na float; u stringu se porovnÃ¡nÃ­ provÃ¡dÃ­ lexikograficky.
		-"==, !=" umoÅ¾Åˆuje porovnÃ¡vat operandy rÅ¯znÃ½ch typÅ¯ ( vÄetnÄ› nil ), kdy, nedojde-li k implicitnÃ­ konverzi mezi int a float je vÃ½sledek "false"
		-Bez rozÅ¡Ã­Å™enÃ­ BOOLOP nenÃ­ s vÃ½sledkem porovnÃ¡nÃ­ moÅ¾nÃ© dÃ¡le pracovat a lze	jej vyuÅ¾Ã­t pouze u pÅ™Ã­kazÅ¯ if a while.

	4.2 Priority operÃ¡torÅ¯
		- jde upravit zÃ¡vorkovÃ¡nÃ­m jinak:

		Priorita:	|	OperÃ¡tory	|	Asociativita
		------------|---------------|---------------
			1		|	*	/		|	levÃ¡
			2		|	+	-		|	levÃ¡
		  	3		|	< <= > >=	|	Å¾Ã¡dnÃ¡
		  	4		|	==	!=		|	Å¾Ã¡dnÃ¡

5. VestavÄ›nÃ© funkce
	- u vÅ¡ech lze opÄ›t vynechÃ¡vat zÃ¡vorky
	- \n odÅ™Ã¡dkovÃ¡nÃ­ jinak jeden znak

#	print ( term1 , term2 , â€¦, termğ‘› ) // musÃ­ mÃ­t aspoÅˆ jeden term
	- %d pro vÃ½pis integer, %a pro float
	- nil je vypsÃ¡n jako prÃ¡zdnÃ¡ Å™etÄ›zec
	- vracÃ­ vÅ¾dy hodnotu nil

#	length(s) 
	- VrÃ¡tÃ­ dÃ©lku (poÄet znakÅ¯) Å™etÄ›zce zadanÃ©ho jedinÃ½m parametrem s.	NapÅ™. length("x\nz") vracÃ­ 3. 

#	substr(s, i, n)
	- VrÃ¡tÃ­ podÅ™etÄ›zec zadanÃ©ho Å™etÄ›zce ğ‘ . DruhÃ½m parametrem ğ‘– je dÃ¡n zaÄÃ¡tek poÅ¾adovanÃ©ho podÅ™etÄ›zce (poÄÃ­tÃ¡no od nuly) a tÅ™etÃ­ parametr ğ‘› urÄuje dÃ©lku podÅ™etÄ›zce. Je-li index ğ‘– mimo meze 0 aÅ¾ length(s) nebo ğ‘› < 0, vracÃ­ funkce nil. Je-li ğ‘› > length(s)âˆ’ğ‘–, jsou jako Å™etÄ›zec vrÃ¡ceny od ğ‘–-tÃ©ho znaku vÅ¡echny zbÃ½vajÃ­cÃ­ znaky Å™etÄ›zce ğ‘ .

#	ord(s, i)
	-VrÃ¡tÃ­ ordinÃ¡lnÃ­ hodnotu (ASCII) znaku na pozici ğ‘– v Å™etÄ›zci ğ‘ . Je-li pozice mimo meze Å™etÄ›zce (0 aÅ¾ length(s) - 1), vracÃ­ nil.

#	chr(i)
	-VrÃ¡tÃ­ jednoznakovÃ½ Å™etÄ›zec se znakem, jeho	Å¾ ASCII kÃ³d je zadÃ¡n parametrem	ğ‘–. PÅ™Ã­pad, kdy je ğ‘– mimo interval [0; 255], vede na bÄ›hovou chybu pÅ™i prÃ¡ci s Å™etÄ›zcem.
